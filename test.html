
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.2/addons/p5.dom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@0.14.2/dist/tf.min.js"></script>
    <script>


        // //Define input, which has a size of 5(not including batch dimension)
        // const input = tf.input({shape: [3]});  
        // // First dense layer uses relu activation. 
        // const denseLayer1 = tf.layers.dense({units: 10, activation: 'relu'}); 
        // // Second dense layer uses softmax activation. 
        // const denseLayer2 = tf.layers.dense({units: 2, activation: 'relu'});  
        // // Obtain the output symbolic tensor by applying the layers on the input. 
        // const output = denseLayer2.apply(denseLayer1.apply(input));  
        // // Create the model based on the inputs. 
        // const model = tf.model({inputs: input, outputs: output});  
        // // The model can be used for training, evaluation and prediction. 
        // // For example, the following line runs prediction with the model on // some fake data. 
        // tf.ones([2, 3]).print()
        // let x = tf.tensor([[1, 1, 1]])
        // model.predict(tf.ones([2, 3])).print();
        // model.predict(tf.ones([2, 3])).print();
        // model.predict(x).print();

        
        const model1 = tf.sequential();
        model1.add(tf.layers.dense({units:2, inputShape: [3]}));
        model1.add(tf.layers.dense({units: 4}));
        model1.add(tf.layers.dense({units: 1}));
        model1.summary();


        const model2 = tf.sequential();
        model2.add(tf.layers.dense({units:2, inputShape: [3]}));
        model2.add(tf.layers.dense({units: 4}));
        model2.add(tf.layers.dense({units: 1}));
        model2.summary();
        

        let x = tf.tensor([[1, 1, 1]])
        x.print()
        model1.predict(x).print()



        // function breed(wx, wy){
    

        // } return wz
  
  
        //Function evolution
        let evos = 1
        let w1 = model1.getWeights()
        let w2 = model2.getWeights()

        let weights = new Array()
        weights.push(w1)
        weights.push(w2)
        weights.push(w1)
        weights.push(w2)
        weights.push(w1)
        weights.push(w2)

        function mutate(w){
          let p = Math.random();
          if (p < 0.03) {
            console.log('Mutation occured.')
            w = w*Math.random()
          }
          return w
        }


        function breed(wx, wy){
          let wz = [];
          for (let i = 0; i < wx.length; i++) {
            let wxwy = (mutate(wx[i]) + mutate(wy[i])) / 2;
            wz.push(wxwy)
          }
          return wz
        } 


        function evolve(weights, n){
            let childW = []
            let w1 = weights[weights.length-1*n]
            let w2 = weights[weights.length-2*n]
            //The best birds are located in the end of the array, breed the best two and the best second two birds
            for (let i = 0; i < w1.length; i = i + 2) {
                let wx = w1[i].dataSync();
                let wy = w2[i].dataSync();
                
                //Child weights
                let wz = breed(wx, wy)
                childW.push(wz)
            }            
            evos += 1
            return childW
        }

        //Produces child from best and next best bird
        let child1 = evolve(weights, 1)

        //Produces child from 3:rd and 4:th best
        let child2 = evolve(weights, 2)


        function generate_model(random, weights){
            if (random == 1){
                const model = tf.sequential();
                // First layer must have an input shape defined.
                model.add(tf.layers.dense({units: 2, inputShape: [3]}));
                model.add(tf.layers.dense({units: 4}));
                model.add(tf.layers.dense({units: 1}));
                return model
            } else {
                const model = tf.sequential();
                // First layer must have an input shape defined.
                model.add(tf.layers.dense({units: 2, inputShape: [3], weights: [tf.tensor(weights[0], [3,2]), tf.tensor([0,0])]}));
                model.add(tf.layers.dense({units: 4, weights: [tf.tensor(weights[1], [2,4]), tf.tensor([0,0,0,0])]}));
                model.add(tf.layers.dense({units: 1, weights: [tf.tensor(weights[2], [4,1]), tf.tensor([0])]}));
                return model
            }
        }

        let a = generate_model(1,0)
        let b = generate_model(0, child2)

        console.log('------')
        a.getWeights()[0].print()
        b.getWeights()[0].print()
        a.getWeights()[1].print()
        b.getWeights()[1].print()
        a.getWeights()[2].print()
        b.getWeights()[2].print()
        a.getWeights()[3].print()
        b.getWeights()[3].print()
        a.getWeights()[4].print()
        b.getWeights()[4].print()
        a.getWeights()[5].print()
        b.getWeights()[5].print()


        const model3 = tf.sequential();
        model3.add(tf.layers.dense({units:2, inputShape: [3], weights: [tf.randomUniform([3, 2], 0, 1), tf.randomUniform([2], 0, 0)]}));
        model3.add(tf.layers.dense({units: 4}));
        model3.add(tf.layers.dense({units: 1}));




    </script>

  </head>
  <body>
  </body>
</html>

